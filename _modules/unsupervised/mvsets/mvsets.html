<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>unsupervised.mvsets.mvsets &#8212; MLExtreme 0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../_static/documentation_options.js?v=8dde47fa"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for unsupervised.mvsets.mvsets</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">File: mvsets.py</span>
<span class="sd">Author: Anne Sabourin</span>
<span class="sd">Date: 2025</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">isclose</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">MLExtreme.utils.EVT_basics</span><span class="w"> </span><span class="kn">import</span> <span class="n">rank_transform</span><span class="p">,</span> <span class="n">round_signif</span>



<div class="viewcode-block" id="Angular_bin">
<a class="viewcode-back" href="../../../unsupervised.mvsets.html#unsupervised.mvsets.mvsets.Angular_bin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Angular_bin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Building blocks of angular minimum-volume sets (mvsets)</span>
<span class="sd">    constructed from a regular paving of the unit sphere for the</span>
<span class="sd">    infinite norm. Geometrically, each grid is a rectangle on the</span>
<span class="sd">    positive orthant of the unit sphere defined from the infinite</span>
<span class="sd">    norm, of the kind:</span>

<span class="sd">    prod_{i in {1, ..., d}, i != i_0} [j_i/J, (j_i+1)/J) x {e_{i_0}}</span>

<span class="sd">    where j_i in {0, ..., J-1}, J is the chosen number of basic</span>
<span class="sd">    subdivisions of the interval [0, 1) and i_0 is the index of the</span>
<span class="sd">    canonical basis vector e_{i_0} normal to the face where the bin is</span>
<span class="sd">    located.</span>

<span class="sd">    Internally a bin is encoded as a np.array of integers in 0, ..., J-1</span>
<span class="sd">    of dimension d, containing the lower end points of the intervals in</span>
<span class="sd">    the product, except for the i_0^{th} entry which is equal to J. A hash</span>
<span class="sd">    function is provided to enable quick responses to queries about the</span>
<span class="sd">    existence of keys in a dictionary of `angular_bin` class instances.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="c1">##self.subface = np.argmax(coords)</span>
        <span class="n">discrete_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">discrete_coord</span><span class="p">)</span>
        <span class="n">id_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">discrete_coord</span> <span class="o">==</span> <span class="n">J</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A bin cannot be on an edge.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">discrete_coord</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">exponents</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exponents</span> <span class="o">*</span> <span class="n">coords</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Angular_bin</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="get_angular_bin">
<a class="viewcode-back" href="../../../unsupervised.mvsets.html#unsupervised.mvsets.mvsets.get_angular_bin">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_angular_bin</span><span class="p">(</span><span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">J</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Angular_bin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the angular bin for a given point.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    point : np.array</span>
<span class="sd">        The point for which to find the angular bin.</span>
<span class="sd">    J : int</span>
<span class="sd">        The number of subdivisions of the interval [0, 1).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    Angular_bin</span>
<span class="sd">        The angular bin corresponding to the given point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">point</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
    <span class="n">edge_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># move the point away from the edge by decreasing all but the</span>
    <span class="c1"># one random coordinate by a small enough value so that the shifted</span>
    <span class="c1"># point belongs to the next adjacent bin.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_indices</span><span class="p">))</span>
        <span class="n">other_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">edge_indices</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other_indices</span><span class="p">:</span>
            <span class="n">angle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">J</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Angular_bin</span><span class="p">(</span><span class="n">J</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span></div>



<div class="viewcode-block" id="sort_bins_by_mass">
<a class="viewcode-back" href="../../../unsupervised.mvsets.html#unsupervised.mvsets.mvsets.sort_bins_by_mass">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sort_bins_by_mass</span><span class="p">(</span><span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">J</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Angular_bin</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sort angular bins by their mass.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    X : np.array</span>
<span class="sd">        The input data.</span>
<span class="sd">    J : int</span>
<span class="sd">        The number of subdivisions of the interval [0, 1).</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    list[Angular_bin]</span>
<span class="sd">        A list of angular bins sorted by mass in descending order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bin_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># pdb.set_trace()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,]</span>
        <span class="n">ang_bin</span> <span class="o">=</span> <span class="n">get_angular_bin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ang_bin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bin_dict</span><span class="p">:</span>
            <span class="n">bin_dict</span><span class="p">[</span><span class="n">ang_bin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bin_dict</span><span class="p">[</span><span class="n">ang_bin</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">sorted_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">bin_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sorted_list</span></div>



<div class="viewcode-block" id="Xmvset">
<a class="viewcode-back" href="../../../unsupervised.mvsets.html#unsupervised.mvsets.mvsets.Xmvset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Xmvset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Minimum-volume set estimation and anomaly scoring.</span>

<span class="sd">    Implements the methods developed in [1].</span>

<span class="sd">    Compared with the implementation proposed in [1] the only  difference resides on the data structure manipulation performs to affect points to the building blocks of the mass-volume sets. This doess not affect the output.</span>

<span class="sd">    References</span>
<span class="sd">    _________</span>
<span class="sd">    [1] Thomas, A., Clémençon, S., Gramfort, A., &amp; Sabourin, A. (2017, April). Anomaly Detection in Extreme Regions via Empirical MV-sets on the Sphere. In AISTATS (Vol. 54).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresh_train</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thresh_predict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the Xmvset model.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        thresh_train : float, optional</span>
<span class="sd">            Threshold for identifying extreme points during training.</span>
<span class="sd">        thresh_predict : float, optional</span>
<span class="sd">            Threshold for identifying extreme points during prediction.</span>
<span class="sd">        J : int, optional</span>
<span class="sd">            Number of subdivisions of the interval [0, 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresh_train</span> <span class="o">=</span> <span class="n">thresh_train</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresh_predict</span> <span class="o">=</span> <span class="n">thresh_predict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">J</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masses</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtrain</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Xmvset.set_default_J">
<a class="viewcode-back" href="../../../unsupervised.mvsets.html#unsupervised.mvsets.mvsets.Xmvset.set_default_J">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_default_J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the default value for J based on the input data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        X : np.array</span>
<span class="sd">            The input data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">default_J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">n</span> <span class="o">/</span> <span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">default_J</span></div>


<div class="viewcode-block" id="Xmvset.fit">
<a class="viewcode-back" href="../../../unsupervised.mvsets.html#unsupervised.mvsets.mvsets.Xmvset.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit the model to the input data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        X : np.array</span>
<span class="sd">            The input data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># # Standardize X if needed</span>
        <span class="c1"># if standardize:</span>
        <span class="c1">#     Xt = rank_transform(X)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     Xt = X</span>
        <span class="n">Xt</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">norm_Xt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Xt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Set the training threshold if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresh_train</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thresh_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">norm_Xt</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">norm_Xt</span><span class="p">)))</span>

        <span class="c1"># define extreme samples</span>
        <span class="n">X_ext</span> <span class="o">=</span> <span class="n">Xt</span><span class="p">[</span><span class="n">norm_Xt</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresh_train</span><span class="p">]</span>
        <span class="c1"># Update total mass accordingly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_extremes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_ext</span><span class="p">)</span>
        <span class="c1"># self.total_mass = self.thresh_train * self.number_extremes / len(norm_Xt)</span>

        <span class="c1"># set J if not provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_default_J</span><span class="p">(</span><span class="n">X_ext</span><span class="p">)</span>
        <span class="n">angular_bins</span> <span class="o">=</span> <span class="n">sort_bins_by_mass</span><span class="p">(</span><span class="n">X_ext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>

        <span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">angular_bins</span><span class="p">])</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">angular_bins</span><span class="p">])</span>
        <span class="c1"># pdb.set_trace()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masses</span> <span class="o">=</span> <span class="n">masses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span></div>

        <span class="c1"># self.list_angular_bins = angular_bins</span>
        <span class="c1"># self.Xtrain = X</span>

<div class="viewcode-block" id="Xmvset.predict">
<a class="viewcode-back" href="../../../unsupervised.mvsets.html#unsupervised.mvsets.mvsets.Xmvset.predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>  <span class="c1"># , standardize=True):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Predicts whether extreme points belong to an extreme angular minimum-volume</span>
<span class="sd">        set at level alpha.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        X_test : np.array</span>
<span class="sd">            Array of test data.</span>
<span class="sd">        alpha : float</span>
<span class="sd">            Proportion of extreme points contained in the angular minimum-volume set.</span>
<span class="sd">        standardize : bool, optional</span>
<span class="sd">            If True, the test points are rank-transformed based on the training data.</span>
<span class="sd">            Default is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        np.array</span>
<span class="sd">            An array of boolean values of the same length as X_test, indicating</span>
<span class="sd">            whether each point belongs to the extreme angular minimum-volume set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the model has not been trained&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresh_predict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thresh_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresh_train</span>
        <span class="c1"># cumulative masses of bins preliminarily sorted in decreasing order</span>
        <span class="n">cum_rel_masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_extremes</span>
        <span class="c1"># indices of bins where cumulative mass exceeds alpha</span>
        <span class="n">id_sets_enough_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cum_rel_masses</span> <span class="o">&gt;=</span> <span class="n">alpha</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># first index such that the cumulative mass exceeds alpha</span>
        <span class="n">id_mvset</span> <span class="o">=</span> <span class="n">id_sets_enough_mass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># create a set of bins that form the mvset at level alpha.</span>
        <span class="c1"># These are the bins with index less than id_mvset in the array of bins</span>
        <span class="c1"># represented by self.coords</span>
        <span class="n">set_bins_mvset</span> <span class="o">=</span> <span class="p">{</span><span class="n">Angular_bin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">id_mvset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="c1"># pdb.set_trace()</span>
        <span class="c1"># select extreme samples</span>
        <span class="n">Norm_Xtest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mask_test</span> <span class="o">=</span> <span class="n">Norm_Xtest</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresh_predict</span>
        <span class="n">X_test_extreme</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="n">mask_test</span><span class="p">]</span>
        <span class="n">n_extremes_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test_extreme</span><span class="p">)</span>
        <span class="c1"># among extreme samples, test which ones belong to the mvset :</span>
        <span class="c1"># a sample belongs to a mvset iff the angular component of the sample</span>
        <span class="c1"># belongs to a bin  which is part of  the mvset.</span>
        <span class="n">is_not_member</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_extremes_test</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_extremes_test</span><span class="p">):</span>
            <span class="n">is_not_member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">get_angular_bin</span><span class="p">(</span><span class="n">X_test_extreme</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set_bins_mvset</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">is_not_member</span><span class="p">,</span> <span class="n">X_test_extreme</span><span class="p">,</span> <span class="n">mask_test</span></div>


<div class="viewcode-block" id="Xmvset.score">
<a class="viewcode-back" href="../../../unsupervised.mvsets.html#unsupervised.mvsets.mvsets.Xmvset.score">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">angular_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the angular score of extreme points defined simply as an</span>
<span class="sd">        un-normalized histogram-based estimated angular density.</span>
<span class="sd">        The lower, the more abnormal.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        X_test : np.array</span>
<span class="sd">            Array of test data.</span>
<span class="sd">        angular_only : bool, optional</span>
<span class="sd">            If True, only the angular score is returned. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        np.array</span>
<span class="sd">            An array of scores of the same length as X_test.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the model has not been trained&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresh_predict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thresh_predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresh_train</span>

        <span class="c1"># create a dictionary (angular_bins, num_points)</span>
        <span class="n">bin_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Angular_bin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">))</span>
        <span class="p">}</span>

        <span class="c1"># select extreme samples</span>
        <span class="n">Norm_Xtest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mask_test</span> <span class="o">=</span> <span class="n">Norm_Xtest</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresh_predict</span>
        <span class="n">X_test_extreme</span> <span class="o">=</span> <span class="n">X_test</span><span class="p">[</span><span class="n">mask_test</span><span class="p">]</span>
        <span class="n">n_extremes_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test_extreme</span><span class="p">)</span>

        <span class="c1"># compute the angular score</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_extremes_test</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_extremes_test</span><span class="p">):</span>
            <span class="n">bin_key</span> <span class="o">=</span> <span class="n">get_angular_bin</span><span class="p">(</span><span class="n">X_test_extreme</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bin_key</span> <span class="ow">in</span> <span class="n">bin_dict</span><span class="p">:</span>
                <span class="n">ang_score</span> <span class="o">=</span> <span class="n">bin_dict</span><span class="p">[</span><span class="n">bin_key</span><span class="p">]</span>  <span class="c1"># number of extreme angles in that bin</span>
                <span class="k">if</span> <span class="n">angular_only</span><span class="p">:</span>
                    <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang_score</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">score</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ang_score</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X_test_extreme</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">score</span><span class="p">,</span> <span class="n">X_test_extreme</span><span class="p">,</span> <span class="n">mask_test</span></div>
</div>



<span class="c1"># workflow:</span>

<span class="c1"># input: data</span>
<span class="c1"># - select extremes and make angles/radii</span>

<span class="c1"># - make sorted angular histogram</span>
<span class="c1"># - make angular mvsets with of defined (relative) mass level</span>
<span class="c1">#          --&gt; OUTPUT: ordered list of cases +</span>
<span class="c1">#           ---&gt; indicator function(level, point)</span>
<span class="c1">#           --&gt; angular extremal scoring function</span>
<span class="c1">#           ---&gt; extremal scoring</span>


<span class="c1"># &quot;&quot;&quot;</span>
<span class="c1"># File: mvsets.py</span>
<span class="c1"># Author: Anne Sabourin</span>
<span class="c1"># Date: 2025-05-02</span>
<span class="c1"># &quot;&quot;&quot;</span>

<span class="c1"># import numpy as np</span>
<span class="c1"># from math import isclose</span>
<span class="c1"># import matplotlib.pyplot as plt</span>
<span class="c1"># from copy import deepcopy</span>
<span class="c1"># from ...utils.EVT_basics import rank_transform, round_signif</span>


<span class="c1"># class Angular_bin:</span>
<span class="c1">#     &quot;&quot;&quot;Building blocks of angular minimum-volume sets (mvsets)</span>
<span class="c1">#     constructed from a regular paving of the unit sphere for the</span>
<span class="c1">#     infinite norm. Geometrically, each grid is a rectangle on the</span>
<span class="c1">#     positive orthant of the unit sphere defined from the infinite</span>
<span class="c1">#     norm, of the kind:</span>

<span class="c1">#     prod_{i in {1, ..., d}, i != i_0} [j_i/J, (j_i+1)/J) x {e_{i_0}}</span>

<span class="c1">#     where j_i in {0, ..., J-1}, J is the chosen number of basic</span>
<span class="c1">#     subdivisions of the interval [0, 1) and i_0 is the index of the</span>
<span class="c1">#     canonical basis vector e_{i_0} normal to the face where the bin is</span>
<span class="c1">#     located.</span>

<span class="c1">#     Internally a bin is encoded as a np.array of integers in 0, ..., J-1</span>
<span class="c1">#     of dimension d, containing the lower end points of the intervals in</span>
<span class="c1">#     the product, except for the i_0^{th} entry which is equal to J. A hash</span>
<span class="c1">#     function is provided to enable quick responses to queries about the</span>
<span class="c1">#         existence of keys in a dictionary of `angular_bin` class instances.</span>

<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     def __init__(self, coords: np.array):</span>
<span class="c1">#         ##self.subface = np.argmax(coords)</span>
<span class="c1">#         discrete_coord = np.floor(coords).astype(int)</span>
<span class="c1">#         J = np.max(discrete_coord)</span>
<span class="c1">#         id_max = np.where(discrete_coord == J)[0]</span>
<span class="c1">#         if len(id_max) &gt; 1:</span>
<span class="c1">#             raise ValueError(&quot;A bin cannot be on an edge.&quot;)</span>
<span class="c1">#         self.coords = discrete_coord</span>

<span class="c1">#     def __hash__(self):</span>
<span class="c1">#         coords = np.array(self.coords)</span>
<span class="c1">#         J = np.max(coords)</span>
<span class="c1">#         dim = len(coords)</span>
<span class="c1">#         exponents = (J + 1) ** np.arange(dim)</span>
<span class="c1">#         return int(np.sum(exponents * coords))</span>

<span class="c1">#     def __eq__(self, other):</span>
<span class="c1">#         if isinstance(other, Angular_bin):</span>
<span class="c1">#             return np.array_equal(self.coords, other.coords)</span>
<span class="c1">#         return False</span>


<span class="c1"># def get_angular_bin(point: np.array, J: int) -&gt; Angular_bin:</span>
<span class="c1">#     angle = point / np.max(point)</span>
<span class="c1">#     edge_indices = np.where(np.isclose(angle, 1))[0]</span>
<span class="c1">#     # move the point away from the edge by decreasing all but the</span>
<span class="c1">#     # one random coordinate by a small enough value so that the shifted</span>
<span class="c1">#     # point belongs to the next adjacent bin.</span>
<span class="c1">#     if len(edge_indices) &gt; 1:</span>
<span class="c1">#         j = np.random.randint(0, len(edge_indices))</span>
<span class="c1">#         other_indices = np.delete(edge_indices, j)</span>
<span class="c1">#         for i in other_indices:</span>
<span class="c1">#             angle[i] = angle[i] - 1 / (2 * J)</span>

<span class="c1">#     return Angular_bin(J * angle)</span>


<span class="c1"># def sort_bins_by_mass(X: np.array, J: int) -&gt; list[Angular_bin]:</span>
<span class="c1">#     bin_dict = {}</span>
<span class="c1">#     n = np.shape(X)[0]</span>
<span class="c1">#     # pdb.set_trace()</span>
<span class="c1">#     for i in range(n):</span>
<span class="c1">#         x = X[i,]</span>
<span class="c1">#         ang_bin = get_angular_bin(x, J)</span>
<span class="c1">#         if ang_bin not in bin_dict:</span>
<span class="c1">#             bin_dict[ang_bin] = 1</span>
<span class="c1">#         else:</span>
<span class="c1">#             bin_dict[ang_bin] += 1</span>

<span class="c1">#     sorted_list = sorted(bin_dict.items(), key=lambda x: x[1], reverse=True)</span>
<span class="c1">#     return sorted_list</span>


<span class="c1"># class Xmvset:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     minimum-volume set estimation and anomaly scoring</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     def __init__(self, thresh_train=None, thresh_predict=None, J=None):</span>
<span class="c1">#         self.thresh_train = thresh_train</span>
<span class="c1">#         self.thresh_predict = thresh_predict</span>
<span class="c1">#         self.J = J</span>
<span class="c1">#         self.masses = None</span>
<span class="c1">#         self.coords = None</span>
<span class="c1">#         self.Xtrain = None</span>

<span class="c1">#     def set_default_J(self, X):</span>
<span class="c1">#         n = len(X)</span>
<span class="c1">#         d = np.shape(X)[1]</span>
<span class="c1">#         default_J = np.ceil((n / d**2) ** (1 / (2 * (d - 1))))</span>
<span class="c1">#         self.J = default_J</span>

<span class="c1">#     def fit(self, X):</span>
<span class="c1">#         # # Standardize X if needed</span>
<span class="c1">#         # if standardize:</span>
<span class="c1">#         #     Xt = rank_transform(X)</span>
<span class="c1">#         # else:</span>
<span class="c1">#         #     Xt = X</span>
<span class="c1">#         Xt = X</span>
<span class="c1">#         norm_Xt = np.max(Xt, axis=1)</span>

<span class="c1">#         # Set the training threshold if not provided</span>
<span class="c1">#         if self.thresh_train is None:</span>
<span class="c1">#             self.thresh_train = np.quantile(norm_Xt, 1 - 1 / np.sqrt(len(norm_Xt)))</span>

<span class="c1">#         # define extreme samples</span>
<span class="c1">#         X_ext = Xt[norm_Xt &gt; self.thresh_train]</span>
<span class="c1">#         # Update total mass accordingly</span>
<span class="c1">#         self.number_extremes = len(X_ext)</span>
<span class="c1">#         # self.total_mass = self.thresh_train * self.number_extremes / len(norm_Xt)</span>

<span class="c1">#         # set J if not provided</span>
<span class="c1">#         if self.J is None:</span>
<span class="c1">#             self.set_default_J(X_ext)</span>
<span class="c1">#         angular_bins = sort_bins_by_mass(X_ext, self.J)</span>

<span class="c1">#         masses = np.array([item[1] for item in angular_bins])</span>
<span class="c1">#         coords = np.array([item[0].coords for item in angular_bins])</span>
<span class="c1">#         # pdb.set_trace()</span>
<span class="c1">#         self.masses = masses</span>
<span class="c1">#         self.coords = coords</span>
<span class="c1">#         # self.list_angular_bins = angular_bins</span>
<span class="c1">#         # self.Xtrain = X</span>

<span class="c1">#     def predict(self, X_test, alpha):  # , standardize=True):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Predicts whether extreme points belong to an extreme angular minimum-volume</span>
<span class="c1">#         set at level alpha.</span>

<span class="c1">#         Parameters:</span>
<span class="c1">#         -----------</span>
<span class="c1">#         Xtest : np.array</span>
<span class="c1">#             Array of test data.</span>
<span class="c1">#         alpha : float</span>
<span class="c1">#             Proportion of extreme points contained in the angular minimum-volume set.</span>
<span class="c1">#         standardize : bool, optional</span>
<span class="c1">#             If True, the test points are rank-transformed based on the training data.</span>
<span class="c1">#             Default is True.</span>

<span class="c1">#         Returns: --------</span>
<span class="c1">#         np.array *</span>
<span class="c1">#             An array of boolean values of the same length as Xtest, indicating</span>
<span class="c1">#             whether each point belongs to the extreme angular minimum-volume set.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         if self.masses is None:</span>
<span class="c1">#             raise ValueError(&quot;the model has not been trained&quot;)</span>
<span class="c1">#         if self.thresh_predict is None:</span>
<span class="c1">#             self.thresh_predict = self.thresh_train</span>
<span class="c1">#         # cumulative masses of bins preliminarily sorted in decreasing order</span>
<span class="c1">#         cum_rel_masses = np.cumsum(self.masses) / self.number_extremes</span>
<span class="c1">#         # indices of bins where cumulative mass exceeds alpha</span>
<span class="c1">#         id_sets_enough_mass = np.where(cum_rel_masses &gt;= alpha)[0]</span>
<span class="c1">#         # first index such that the cumulative mass exceeds alpha</span>
<span class="c1">#         id_mvset = id_sets_enough_mass[0]</span>
<span class="c1">#         # create a set of bins that form the mvset at level alpha.</span>
<span class="c1">#         # These are the bins with index less than id_mvset in the array of bins</span>
<span class="c1">#         # represented by self.coords</span>
<span class="c1">#         set_bins_mvset = {Angular_bin(self.coords[i]) for i in range(id_mvset + 1)}</span>
<span class="c1">#         # pdb.set_trace()</span>
<span class="c1">#         # select extreme samples</span>
<span class="c1">#         Norm_Xtest = np.max(X_test, axis=1)</span>
<span class="c1">#         mask_test = Norm_Xtest &gt;= self.thresh_predict</span>
<span class="c1">#         X_test_extreme = X_test[mask_test]</span>
<span class="c1">#         n_extremes_test = len(X_test_extreme)</span>
<span class="c1">#         # among extreme samples, test which ones belong to the mvset :</span>
<span class="c1">#         # a sample belongs to a mvset iff the angular component of the sample</span>
<span class="c1">#         # belongs to a bin  which is part of  the mvset.</span>
<span class="c1">#         is_not_member = np.zeros(n_extremes_test)</span>
<span class="c1">#         for i in range(n_extremes_test):</span>
<span class="c1">#             is_not_member[i] = (</span>
<span class="c1">#                 get_angular_bin(X_test_extreme[i], self.J) not in set_bins_mvset</span>
<span class="c1">#             )</span>
<span class="c1">#         return is_not_member, X_test_extreme, mask_test</span>

<span class="c1">#     def score(self, X_test, angular_only=False):</span>
<span class="c1">#         &quot;&quot;&quot;return the angular score of extreme points defined simply as an</span>
<span class="c1">#         un-normalized histogram-based estimated angular density.</span>
<span class="c1">#         The lower, the more abnormal.&quot;&quot;&quot;</span>
<span class="c1">#         if self.masses is None:</span>
<span class="c1">#             raise ValueError(&quot;the model has not been trained&quot;)</span>
<span class="c1">#         if self.thresh_predict is None:</span>
<span class="c1">#             self.thresh_predict = self.thresh_train</span>

<span class="c1">#         # create a dictionary (angular_bins, num_points)</span>
<span class="c1">#         bin_dict = {</span>
<span class="c1">#             Angular_bin(self.coords[i]): self.masses[i] for i in range(len(self.masses))</span>
<span class="c1">#         }</span>

<span class="c1">#         # select extreme samples</span>
<span class="c1">#         Norm_Xtest = np.max(X_test, axis=1)</span>
<span class="c1">#         mask_test = Norm_Xtest &gt;= self.thresh_predict</span>
<span class="c1">#         X_test_extreme = X_test[mask_test]</span>
<span class="c1">#         n_extremes_test = len(X_test_extreme)</span>

<span class="c1">#         # compute the angular score</span>
<span class="c1">#         score = np.zeros(n_extremes_test)</span>
<span class="c1">#         for i in range(n_extremes_test):</span>
<span class="c1">#             bin_key = get_angular_bin(X_test_extreme[i], self.J)</span>
<span class="c1">#             if bin_key in bin_dict:</span>
<span class="c1">#                 ang_score = bin_dict[bin_key]  # number of extreme angles in that bin</span>
<span class="c1">#                 if angular_only:</span>
<span class="c1">#                     score[i] = ang_score</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     score[i] = ang_score / np.max(X_test_extreme[i]) ** 2</span>
<span class="c1">#         return score, X_test_extreme, mask_test</span>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">MLExtreme</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../supervised.html">supervised subpackage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../unsupervised.html">unsupervised subpackage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">utils subpackage</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Anne Sabourin, Pierre-Antoine Amiand-Leroy.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>