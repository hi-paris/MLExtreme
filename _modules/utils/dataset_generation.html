<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>utils.dataset_generation &#8212; MLExtreme 0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=8dde47fa"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for utils.dataset_generation</h1><div class="highlight"><pre>
<span></span><span class="c1"># Author: Anne Sabourin</span>
<span class="c1"># Date: 2025</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Submodule for Dataset Generation and Plotting Utilities</span>

<span class="sd">This submodule provides essential functions for generating datasets and plotting utilities used throughout the MLExtreme package. It focuses on the Pareto Margins convention for modeling multivariate extremes, featuring an angular component that follows a flexible Dirichlet Mixture distribution. Additionally, the submodule includes implementations of the multivariate symmetric Logistic model.</span>

<span class="sd">For supervised learning scenarios, the submodule supports the generation of datasets consisting of covariate-target pairs, where the target can be either binary or continuous. The covariates are designed to be regularly varying, and the submodule also includes functionality for rescaling targets.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">loggamma</span>  <span class="c1"># gamma, betaln</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>


<div class="viewcode-block" id="normalize_param_dirimix">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.normalize_param_dirimix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize_param_dirimix</span><span class="p">(</span><span class="n">Mu</span><span class="p">,</span> <span class="n">wei</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modifies the Dirichlet centers matrix `Mu` and the weights `wei`</span>
<span class="sd">    for the Dirichlet mixture model in Pareto margins in order to</span>
<span class="sd">    satisfy a moments constraint on the angular distribution of</span>
<span class="sd">    extremes.</span>

<span class="sd">    The constraint is that :math:`E(\\Theta) = (1/d, \\ldots, 1/d)`, where</span>
<span class="sd">    :math:`d` is the dimension of the ambient space. For a Dirichlet</span>
<span class="sd">    mixture density with parameters :math:`w = wei, M=Mu`, this is equivalent to</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\sum_{j=1}^k w_j M_{j, \\cdot} = \\left(\\frac{1}{d}, \\ldots, \\frac{1}{d}\\right)</span>

<span class="sd">    The function accepts a matrix `Mu` of dimension (k, d) and a weights</span>
<span class="sd">    vector `wei` of dimension (k,). It normalizes these inputs to satisfy</span>
<span class="sd">    the moment constraint on the angular distribution, which is derived from</span>
<span class="sd">    Pareto-margins standardization. This normalization ensures that each row</span>
<span class="sd">    of the resulting `Mu_modif` matrix sums to 1, and the barycenter of the</span>
<span class="sd">    rows, weighted by `wei_modif`, is :math:`(1/d, \\ldots, 1/d)`. For further</span>
<span class="sd">    details, refer to Boldi &amp; Davison and Sabourin &amp; Naveau. The normalization</span>
<span class="sd">    process follows the method described in Chiapino et al. (see references below).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Mu : np.ndarray</span>
<span class="sd">        A k x p matrix with positive entries, with rows summing to one.</span>
<span class="sd">    wei : np.ndarray</span>
<span class="sd">        A weights vector of length k, with nonnegative entries, summing to one.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">            - Mu1 (np.ndarray): The normalized matrix where columns sum to 1.</span>
<span class="sd">            - wei1 (np.ndarray): The updated weights vector of length p.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; p = 3; k = 2</span>
<span class="sd">    &gt;&gt;&gt; Mu0 = 3*np.random.random(2*3).reshape(k, p)</span>
<span class="sd">    &gt;&gt;&gt; wei0 = 4*np.random.random(k)</span>
<span class="sd">    &gt;&gt;&gt; Mu, wei = normalize_param_dirimix(Mu0, wei0)</span>
<span class="sd">    &gt;&gt;&gt; print(f&#39;row sums of Mu : {np.sum(Mu, axis=1)}&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(f&#39;barycenter of `Mu` rows with weights `wei` : {np.sum(Mu*wei.reshape(-1, 1), axis=0)}&#39;)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Boldi, M. O., &amp; Davison, A. C. (2007). A mixture model for multivariate extremes. Journal of the Royal Statistical Society Series B: Statistical Methodology, 69(2), 217-229.</span>

<span class="sd">    [2] Sabourin, A., &amp; Naveau, P. (2014). Bayesian Dirichlet mixture model for multivariate extremes: a re-parametrization. Computational Statistics &amp; Data Analysis, 71, 542-567.</span>

<span class="sd">    [3] Chiapino, M., Clémençon, S., Feuillard, V., &amp; Sabourin, A. (2020). A multivariate extreme value theory approach to anomaly clustering and visualization. Computational Statistics, 35(2), 607-628.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">wei</span><span class="p">)</span> <span class="o">@</span> <span class="n">Mu</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Rho</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Rho_csum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Rho</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># length p. Barycenter of the input.</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Rho_csum</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One column of Mu is zero&quot;</span><span class="p">)</span>
    <span class="n">Rho1</span> <span class="o">=</span> <span class="n">Rho</span> <span class="o">/</span> <span class="p">(</span><span class="n">Rho_csum</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>  <span class="c1"># Rho1 has columns summing to 1/p</span>
    <span class="n">wei1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Rho1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Updated weights vector of length p</span>
    <span class="n">Mu1</span> <span class="o">=</span> <span class="n">Rho1</span> <span class="o">/</span> <span class="n">wei1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Mu1</span><span class="p">,</span> <span class="n">wei1</span></div>



<div class="viewcode-block" id="gen_dirichlet">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.gen_dirichlet">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_dirichlet</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate angular random samples from a `Dirichlet distribution &lt;https://en.wikipedia.org/wiki/Dirichlet_distribution&gt;`_ with parameter `a`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : 1D or 2D np.ndarray, shape (n, p) or (p,)</span>
<span class="sd">        Parameters for the Dirichlet distribution of each sample.</span>
<span class="sd">    size : int, optional</span>
<span class="sd">        Number of samples to generate. Default is 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray, shape (n, p)</span>
<span class="sd">        An array of Dirichlet samples, each normalized to sum to 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># a is a 1D array</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># a is a 2D array</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;if a is a 2D array, </span><span class="se">\</span>
<span class="s2">            n should be equal to the number of rows of a&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a must be either a 1D or 2D array&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">sm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">sm</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span></div>



<div class="viewcode-block" id="pdf_dirichlet">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.pdf_dirichlet">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pdf_dirichlet</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the probability density function of a `Dirichlet distribution &lt;https://en.wikipedia.org/wiki/Dirichlet_distribution&gt;`_ with parameter `a`, at each point represented as a row in the data matrix `x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray, shape (n, d) or (d,)</span>
<span class="sd">        Data matrix where each row is a point on the (d-1)-dimensional simplex.</span>
<span class="sd">    a : ndarray, shape (d,)</span>
<span class="sd">        Parameters for the Dirichlet distribution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray, shape (n,)</span>
<span class="sd">        Probability density at each row of `x` for the given Dirichlet</span>
<span class="sd">        distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;Each row of x must sum to 1&quot;</span>
    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span>
        <span class="s2">&quot;Each row of x and a must have </span><span class="se">\</span>
<span class="s2">                                      the same length&quot;</span>
    <span class="p">)</span>

    <span class="n">log_numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">log_denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">loggamma</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">-</span> <span class="n">loggamma</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="n">log_pdf</span> <span class="o">=</span> <span class="n">log_numerator</span> <span class="o">-</span> <span class="n">log_denominator</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)</span></div>



<div class="viewcode-block" id="pdf_dirimix">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.pdf_dirimix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pdf_dirimix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Mu</span><span class="p">,</span> <span class="n">wei</span><span class="p">,</span> <span class="n">lnu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Density function of a Dirichlet mixture distribution on the (d-1)-dimensional simplex evaluated at each</span>
<span class="sd">    row in the data matrix `x`.</span>

<span class="sd">    Each Dirichlet mixture component has weight given by the jth entry</span>
<span class="sd">    of `wei`, and Dirichlet parameter (see :func:`pdf_dirichlet`) :math:`a_j=\\nu_j \\mu_j`, where</span>
<span class="sd">    :math:`\\nu_j = \\exp(\\textrm{lnu}_j)`, :math:`\\mu_j` is the jth</span>
<span class="sd">    row of matrix `Mu`, :math:`\\textrm{lnu}_j` is the jth entry of `lnu`.</span>
<span class="sd">    The Dirichlet mixture density writes, for `x` in the unit simplex,</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x, \\textrm{Mu}, \\textrm{wei}, \\textrm{lnu}) = \\sum_{j=0}^{k-1} \</span>
<span class="sd">    \\textrm{wei}[j] \\textrm{dirichlet}(x | \\textrm{Mu}[j, :], \\exp(\\textrm{lnu}[j])),</span>

<span class="sd">    where &quot;dirichlet&quot; is the Dirichlet density with parameter \</span>
<span class="sd">    :math:`a=\\nu\\mu`,</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>

<span class="sd">        \\textrm{dirichlet}(x | \\mu, \\nu) = \\frac{\\Gamma(\\nu)}{\\prod_{i=1}^d \\Gamma(\\nu \\mu_i)}\\prod_{i=1}^d x_i^{\\nu \\mu_i - 1}.</span>

<span class="sd">    </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray, shape (n, d) or (d,)</span>
<span class="sd">        Data matrix where each row is a point on the (d-1)-dimensional simplex.</span>
<span class="sd">    Mu : ndarray, shape (k, d)</span>
<span class="sd">        Matrix of means for the Dirichlet concentration parameters.</span>
<span class="sd">        Each row must contain non-negative entries and sum to one.</span>
<span class="sd">        A moments constraint arises from standardization to unit Pareto margins.</span>
<span class="sd">        This constraint is that</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\sum_{j=1}^{k} w_j \\mu_j = \\left(\\frac{1}{d}, \\ldots, \\frac{1}{d}\\right).</span>

<span class="sd">        No warning nor error is issued if that constraint is not satisfied, to encompass more general situations.</span>
<span class="sd">    wei : ndarray, shape (k,)</span>
<span class="sd">        Vector of weights for each mixture component. Nonnegative entries, summing to one.</span>
<span class="sd">    lnu : ndarray, shape (k,)</span>
<span class="sd">        Vector of log-scales for each mixture component.</span>

<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray, shape (n,)</span>
<span class="sd">        Density at each row of `x` on the (d-1)-dimensional simplex.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wei</span><span class="p">)</span>
    <span class="n">density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">Mu</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lnu</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">density</span> <span class="o">+=</span> <span class="n">wei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">pdf_dirichlet</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">density</span></div>



<div class="viewcode-block" id="gen_dirimix">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.gen_dirimix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_dirimix</span><span class="p">(</span><span class="n">Mu</span><span class="p">,</span> <span class="n">wei</span><span class="p">,</span> <span class="n">lnu</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate angular samples from a mixture of Dirichlet distributions \</span>
<span class="sd">    described in :func:`pdf_dirimix`</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    size : int (optional)</span>
<span class="sd">        Number of samples to generate.</span>
<span class="sd">    Mu : ndarray, shape (k, p)</span>
<span class="sd">        Matrix of means for the Dirichlet components.</span>
<span class="sd">    wei : ndarray, shape (k,)</span>
<span class="sd">        Vector of weights for each mixture component.</span>
<span class="sd">    lnu : ndarray, shape (k,)</span>
<span class="sd">        Vector of log-scales for each mixture component.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray, shape (size, p)</span>
<span class="sd">        Array of Dirichlet samples generated from the mixture.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">size</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Mu</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lnu</span><span class="p">)</span> <span class="o">!=</span> <span class="n">k</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">wei</span><span class="p">)</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of lnu and wei must be equal to k&quot;</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">cum_wei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">wei</span><span class="p">)</span>

    <span class="n">ms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cum_wei</span> <span class="o">&lt;=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cum_wei</span> <span class="o">&lt;=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="n">matpars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Mu</span><span class="p">[</span><span class="n">ms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lnu</span><span class="p">[</span><span class="n">ms</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">gen_dirichlet</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">matpars</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span></div>



<div class="viewcode-block" id="plot_pdf_dirimix_2D">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.plot_pdf_dirimix_2D">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_pdf_dirimix_2D</span><span class="p">(</span><span class="n">Mu</span><span class="p">,</span> <span class="n">wei</span><span class="p">,</span> <span class="n">lnu</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the Dirichlet mixture density on the 1-D simplex in \</span>
<span class="sd">ambient dimension 2, see :func:`pdf_dirimix`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    Mu : ndarray, shape (2, k)</span>
<span class="sd">        Matrix of means for the Dirichlet concentration parameters.</span>
<span class="sd">    lnu : ndarray, shape (k,)</span>
<span class="sd">        Vector of log-scales for each mixture component.</span>
<span class="sd">    wei : ndarray, shape (k,)</span>
<span class="sd">        Vector of weights for each mixture component.</span>
<span class="sd">    n_points : int, optional</span>
<span class="sd">        Number of points to use for evaluating the density. Default is 500.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_values1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span> <span class="n">n_points</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x_values1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x_values1</span><span class="p">))</span>
    <span class="n">density_values</span> <span class="o">=</span> <span class="n">pdf_dirimix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Mu</span><span class="p">,</span> <span class="n">wei</span><span class="p">,</span> <span class="n">lnu</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_values1</span><span class="p">,</span> <span class="n">density_values</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Mixture Density&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x_values1</span><span class="p">,</span> <span class="n">density_values</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Mixture Density on the 1-D Simplex&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;x[1] first component&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Density&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="plot_pdf_dirimix_3D">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.plot_pdf_dirimix_3D">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_pdf_dirimix_3D</span><span class="p">(</span><span class="n">Mu</span><span class="p">,</span> <span class="n">wei</span><span class="p">,</span> <span class="n">lnu</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the mixture density on the 2D simplex in ambient dimension 3, \</span>
<span class="sd">see :func:`pdf_dirimix`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    Mu : ndarray, shape (3, k)</span>
<span class="sd">        Matrix of means for the Dirichlet concentration parameters.</span>
<span class="sd">    lnu : ndarray, shape (k,)</span>
<span class="sd">        Vector of log-scales for each mixture component.</span>
<span class="sd">    wei : ndarray, shape (k,)</span>
<span class="sd">        Vector of weights for each mixture component.</span>
<span class="sd">    n_points : int, optional</span>
<span class="sd">        Number of points to use for evaluating the density. Default is 500.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x1_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span> <span class="n">n_points</span><span class="p">)</span>
    <span class="n">x2_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span> <span class="n">n_points</span><span class="p">)</span>

    <span class="n">X1</span><span class="p">,</span> <span class="n">X2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x1_values</span><span class="p">,</span> <span class="n">x2_values</span><span class="p">)</span>
    <span class="n">X1</span> <span class="o">=</span> <span class="n">X1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">X2</span> <span class="o">=</span> <span class="n">X2</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">valid_points</span> <span class="o">=</span> <span class="n">X1</span> <span class="o">+</span> <span class="n">X2</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">X1</span> <span class="o">=</span> <span class="n">X1</span><span class="p">[</span><span class="n">valid_points</span><span class="p">]</span>
    <span class="n">X2</span> <span class="o">=</span> <span class="n">X2</span><span class="p">[</span><span class="n">valid_points</span><span class="p">]</span>
    <span class="n">X_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">X1</span> <span class="o">-</span> <span class="n">X2</span><span class="p">))</span>
    <span class="n">density_values</span> <span class="o">=</span> <span class="n">pdf_dirimix</span><span class="p">(</span><span class="n">X_full</span><span class="p">,</span> <span class="n">Mu</span><span class="p">,</span> <span class="n">wei</span><span class="p">,</span> <span class="n">lnu</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">density_values</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Density&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Mixture Density on the 2D Simplex&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;x1 (first component)&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;x2 (second component)&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;k--&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<span class="c1"># ##############################################</span>
<span class="c1"># ## Multivariate symmetric / asymmetric logistic Model</span>
<span class="c1"># ##############################################</span>
<div class="viewcode-block" id="gen_PositiveStable">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.gen_PositiveStable">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_PositiveStable</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate positive stable random variables, useful for generating \</span>
<span class="sd">    Multivariate Logistic variables, see :func:`gen_multilog`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    size : int (optional)</span>
<span class="sd">        Sample size.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Dependence parameter.</span>
<span class="sd">  </span>
<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Sample of positive stable random variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="c1">#    U = stat.uniform.rvs(0, np.pi, size=size, random_state=seed)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="c1"># stat.expon.rvs(size=size, random_state=seed)</span>
    <span class="n">Term_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">U</span><span class="p">)</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">**</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="n">Term_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">U</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Term_1</span> <span class="o">*</span> <span class="n">Term_2</span></div>



<div class="viewcode-block" id="gen_multilog">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.gen_multilog">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_multilog</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate multivariate symmetric logistic random variables via Algorithm 2.1 in [1].</span>

<span class="sd">    [1]: Stephenson, A. (2003). Simulating multivariate extreme value distributions of logistic type.\</span>
<span class="sd">    Extremes, 6, 49-59.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    size : int (optional)</span>
<span class="sd">        Sample size.</span>
<span class="sd">    dim : int</span>
<span class="sd">        Dimension.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Dependence parameter.</span>
<span class="sd">  </span>
<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Sample of multivariate logistic random variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
    <span class="c1">#    W = stat.expon.rvs(size=(size, dim), random_state=seed)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">gen_PositiveStable</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="n">Result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="n">Result</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span> <span class="o">/</span> <span class="n">W</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">])</span> <span class="o">**</span> <span class="n">alpha</span>
    <span class="k">return</span> <span class="n">Result</span></div>



<span class="c1"># ###########################################</span>
<span class="c1"># ### Prediction of a missing component</span>
<span class="c1"># ###########################################</span>


<div class="viewcode-block" id="transform_target_lin">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.transform_target_lin">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transform_target_lin</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">norm_func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform the target vector to achieve approximate independence from the</span>
<span class="sd">    norm of `X` and stabilize the learning algorithms by preventing large target values</span>

<span class="sd">    This function rescales the original target vector `y` into</span>
<span class="sd">    `y&#39; = y / ||X||` to mitigate the influence of the magnitude of `X` on `y`,</span>
<span class="sd">    particularly when `||X||` is large. This transformation is useful for</span>
<span class="sd">    predicting missing components in heavy-tailed multivariate data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array-like</span>
<span class="sd">        The original target vector to be transformed.</span>
<span class="sd">    X : array-like</span>
<span class="sd">        The matrix whose norm is used to rescale `y`.</span>
<span class="sd">    norm_func : callable</span>
<span class="sd">        A function that computes the norm of `X`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y1 : array-like</span>
<span class="sd">        The rescaled target vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm_X</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">norm_X</span>
    <span class="k">return</span> <span class="n">y1</span></div>



<div class="viewcode-block" id="inv_transform_target_lin">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.inv_transform_target_lin">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">inv_transform_target_lin</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">norm_func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse transform the rescaled target vector to its original scale.</span>

<span class="sd">    This function performs the inverse operation of :func:`transform_target_lin`,</span>
<span class="sd">    converting the rescaled target vector back to its original scale by</span>
<span class="sd">    multiplying it by the norm of `X`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array-like</span>
<span class="sd">        The rescaled target vector to be inverse-transformed.</span>
<span class="sd">    X : array-like</span>
<span class="sd">        The matrix whose norm was used to rescale `y`.</span>
<span class="sd">    norm_func : callable</span>
<span class="sd">        The same norm function used in `transform_target_lin`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y_orig : array-like</span>
<span class="sd">        The original target vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm_X</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">y_orig</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">norm_X</span>
    <span class="k">return</span> <span class="n">y_orig</span></div>



<div class="viewcode-block" id="transform_target_nonlin">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.transform_target_nonlin">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transform_target_nonlin</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">norm_order</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Non-linearly transform the target vector to achieve \</span>
<span class="sd">    approximate independence from the norm of `X` and stabilize the</span>
<span class="sd">    learning algorithms by preventing large target values</span>

<span class="sd">    This function rescales the original target vector `y` into `y&#39; = y\</span>
<span class="sd">    / ||[X, y]||_q` to mitigate the influence of the magnitude of `X`\</span>
<span class="sd">    on `y`, particularly when `||[X, y]||_q` is large. This\</span>
<span class="sd">    transformation is useful for predicting missing components in</span>
<span class="sd">    heavy-tailed multivariate data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array-like</span>
<span class="sd">        The original target vector to be transformed.</span>
<span class="sd">    X : array-like</span>
<span class="sd">        The matrix whose norm, combined with `y`, is used to rescale `y`.</span>
<span class="sd">    norm_order : int</span>
<span class="sd">        The order of the norm to be used for the transformation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        The rescaled target vector.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">norm_order</span>
    <span class="n">joint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">norm_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">joint</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span> <span class="o">/</span> <span class="n">norm_full</span></div>



<div class="viewcode-block" id="inv_transform_target_nonlin">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.inv_transform_target_nonlin">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">inv_transform_target_nonlin</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">norm_order</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse transform the rescaled target vector to its original scale in a nonlinear fashion.</span>

<span class="sd">    This function performs the inverse operation of</span>
<span class="sd">    :func:`transform_target_nonlin`,</span>
<span class="sd">    converting the rescaled target vector back to its original scale.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array-like</span>
<span class="sd">        The rescaled target vector to be inverse-transformed.</span>
<span class="sd">    X : array-like</span>
<span class="sd">        The matrix whose norm was used to rescale `y`.</span>
<span class="sd">    norm_order : int</span>
<span class="sd">        The order of the norm used in the transformation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        The original target vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">norm_order</span>
    <span class="n">norm_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">predicted_x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="n">q</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm_x</span>
    <span class="k">return</span> <span class="n">predicted_x</span></div>



<div class="viewcode-block" id="gen_rv_dirimix">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.gen_rv_dirimix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_rv_dirimix</span><span class="p">(</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Mu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]),</span>
    <span class="n">wei</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
    <span class="n">lnu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">]),</span>
    <span class="n">scale_weight_noise</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">index_weight_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">Mu_bulk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">wei_bulk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">lnu_bulk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate `n` points according to a multivariate regularly varying \</span>
<span class="sd">    distribution (heavy-tailed) with regular variation `alpha`.</span>

<span class="sd">    Each point is generated as `X_i = R_i * Theta_i`, where R_i and</span>
<span class="sd">    Theta_i are not independent in the bulk.</span>

<span class="sd">    The noise influence decreases proportionally to</span>
<span class="sd">    `(scale_weight_noise/R)**(index_weight_noise)`, where `R` is the 1-norm of the sample point.</span>
<span class="sd">    This means that as the radius `R` increases, the noise&#39;s effect diminishes, controlled by the</span>
<span class="sd">    `scale_weight_noise` and `index_weight_noise` parameters.</span>

<span class="sd">    Theta is generated as a weighted average of two components:</span>
<span class="sd">    - A &quot;bulk&quot; component, which dominates for small to moderate radii.</span>
<span class="sd">    - A &quot;tail&quot; component, which becomes more significant as the radius increases.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    size : int, optional</span>
<span class="sd">        Number of samples to generate. Default is 1.</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        Shape parameter of the Pareto distribution. Default is 1.</span>
<span class="sd">    Mu : ndarray, shape (k,d)</span>
<span class="sd">        Means for the Dirichlet mixture components.</span>
<span class="sd">    wei : ndarray, shape (k,)</span>
<span class="sd">        Weights for each mixture component.</span>
<span class="sd">    lnu : ndarray, shape (k,)</span>
<span class="sd">        Log-scale parameters for the Dirichlet mixture components.</span>
<span class="sd">    Mu_bulk : ndarray, shape (k,d), optional</span>
<span class="sd">        Parameter matrix of same dimension as Mu, ruling the angular distribution for small to moderate radii.</span>
<span class="sd">    scale_weight_noise : float, optional</span>
<span class="sd">        Scaling factor (&gt;0) for the angular noise. It controls the overall magnitude of the noise added to the angular component.</span>
<span class="sd">        A larger value increases the noise influence, making points more dispersed, while a smaller value reduces noise effect.</span>
<span class="sd">        Default is 1.</span>
<span class="sd">    index_weight_noise : float, optional</span>
<span class="sd">        Exponent ruling how the noise vanishes for large R. It determines how quickly the noise&#39;s influence diminishes as the radius `R` increases.</span>
<span class="sd">        A higher value makes the noise vanish more rapidly, resulting in less noisy points for larger radii.</span>
<span class="sd">        Default is -alpha.</span>
<span class="sd">    wei_bulk : ndarray, shape (k,), optional</span>
<span class="sd">        Weights for each mixture component in the bulk distribution.</span>
<span class="sd">    lnu_bulk : ndarray, shape (k,), optional</span>
<span class="sd">        Log-scale parameters for the Dirichlet mixture components in the bulk distribution.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray, shape (n, d)</span>
<span class="sd">        Array of points generated from the Pareto and Dirichlet mixture.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">if</span> <span class="n">index_weight_noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">index_weight_noise</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">pareto</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">Theta</span> <span class="o">=</span> <span class="n">gen_dirimix</span><span class="p">(</span><span class="n">Mu</span><span class="o">=</span><span class="n">Mu</span><span class="p">,</span> <span class="n">wei</span><span class="o">=</span><span class="n">wei</span><span class="p">,</span> <span class="n">lnu</span><span class="o">=</span><span class="n">lnu</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Mu</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># k_comp = np.shape(Mu)[0]</span>
    <span class="c1"># if Mu_bulk is None:</span>
    <span class="c1">#     Mu_bulk = (1 - Mu)/(dim - 1)</span>
    <span class="k">if</span> <span class="n">Mu_bulk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Mu_bulk_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">((</span><span class="mi">2</span> <span class="o">/</span> <span class="n">dim</span> <span class="o">-</span> <span class="n">Mu</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">))</span>
        <span class="n">r_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Mu_bulk_0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Mu_bulk</span> <span class="o">=</span> <span class="n">Mu_bulk_0</span> <span class="o">/</span> <span class="n">r_0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">wei_bulk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wei_bulk</span> <span class="o">=</span> <span class="n">wei</span>  <span class="c1"># np.ones(k_comp)/k_comp</span>

    <span class="k">if</span> <span class="n">lnu_bulk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lnu_bulk</span> <span class="o">=</span> <span class="n">lnu</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">Noise</span> <span class="o">=</span> <span class="n">gen_dirimix</span><span class="p">(</span><span class="n">Mu</span><span class="o">=</span><span class="n">Mu_bulk</span><span class="p">,</span> <span class="n">wei</span><span class="o">=</span><span class="n">wei_bulk</span><span class="p">,</span> <span class="n">lnu</span><span class="o">=</span><span class="n">lnu_bulk</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="c1"># gen_dirichlet(n, ) np.ones((n, np.shape(Mu)[0])))</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">scale_weight_noise</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">index_weight_noise</span><span class="p">))</span>
    <span class="n">newTheta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">*</span> <span class="n">Theta</span> <span class="o">+</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">Noise</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">newTheta</span>

    <span class="k">return</span> <span class="n">X</span></div>



<div class="viewcode-block" id="gen_classif_data_diriClasses">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.gen_classif_data_diriClasses">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_classif_data_diriClasses</span><span class="p">(</span>
    <span class="n">mu0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]),</span> <span class="n">lnu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">index_weight_noise</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate synthetic classification data with two classes using a Dirichlet mixture model.</span>

<span class="sd">    This function generates synthetic data for binary classification tasks. It creates two classes</span>
<span class="sd">    of data points using a Dirichlet mixture model, where each class is characterized by different</span>
<span class="sd">    mean parameters. The data points are generated using the `gen_rv_dirimix` function, which</span>
<span class="sd">    combines Pareto-distributed radii with Dirichlet-distributed angular components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    mu0 : ndarray, shape (d,), optional</span>
<span class="sd">        Mean parameter for the first class. Default is np.array([0.7, 0.3]).</span>
<span class="sd">    lnu : ndarray, shape (k,), optional</span>
<span class="sd">        Log-scale parameters for the Dirichlet mixture components. If not provided, it is calculated</span>
<span class="sd">        based on the mean parameters.</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        Shape parameter of the Pareto distribution. Default is 4.</span>
<span class="sd">    index_weight_noise : float, optional</span>
<span class="sd">        Exponent ruling how the noise vanishes for large R. Default is 1.</span>
<span class="sd">    size : int, optional</span>
<span class="sd">        Total number of samples to generate. Default is 10.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    X : ndarray, shape (n, d)</span>
<span class="sd">        Array of generated data points.</span>
<span class="sd">    y : ndarray, shape (n,)</span>
<span class="sd">        Array of class labels corresponding to the data points.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function first normalizes the mean parameters and weights for the Dirichlet mixture model.</span>
<span class="sd">    It then generates data points for each class using the `gen_rv_dirimix` function, combining them</span>
<span class="sd">    into a single dataset. The class labels are randomly permuted to ensure a balanced dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mu1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">mu0</span>
    <span class="n">Mu_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu0</span><span class="p">,</span> <span class="n">mu1</span><span class="p">])</span>
    <span class="n">wei_temp</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Mu</span><span class="p">,</span> <span class="n">wei</span> <span class="o">=</span> <span class="n">normalize_param_dirimix</span><span class="p">(</span><span class="n">Mu_temp</span><span class="p">,</span> <span class="n">wei_temp</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lnu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lnu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Mu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">size0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">wei</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">size1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">wei</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Mu0</span> <span class="o">=</span> <span class="n">Mu</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Mu1</span> <span class="o">=</span> <span class="n">Mu</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Dim = np.shape(Mu)[1]</span>
    <span class="n">data0</span> <span class="o">=</span> <span class="n">gen_rv_dirimix</span><span class="p">(</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">Mu0</span><span class="p">,</span>
        <span class="n">wei</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">lnu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lnu</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
        <span class="n">scale_weight_noise</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">),</span>  <span class="c1"># np.sqrt(Dim),</span>
        <span class="n">index_weight_noise</span><span class="o">=</span><span class="n">index_weight_noise</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="n">size0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">data1</span> <span class="o">=</span> <span class="n">gen_rv_dirimix</span><span class="p">(</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">Mu1</span><span class="p">,</span>
        <span class="n">wei</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">lnu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lnu</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
        <span class="n">scale_weight_noise</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">),</span>  <span class="c1"># np.sqrt(Dim),</span>
        <span class="n">index_weight_noise</span><span class="o">=</span><span class="n">index_weight_noise</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="n">size1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">))</span>
    <span class="n">permut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">size0</span> <span class="o">+</span> <span class="n">size1</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">permut</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">permut</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span></div>



<span class="c1"># ## target generation for regression models:</span>
<span class="c1"># specific instance of additive noise nodel considered in Huet et al.</span>
<div class="viewcode-block" id="tail_reg_fun_default">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.tail_reg_fun_default">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tail_reg_fun_default</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Default tail regression function for generating target values.</span>

<span class="sd">    This function is used internally as an argument for</span>
<span class="sd">    :func:`gen_target_CovariateRV`.  The regression function in the</span>
<span class="sd">    tail is defined in a linear model, y = &lt; beta, angle &gt;. `angle` is</span>
<span class="sd">    meant to be the angular component of the original input, and</span>
<span class="sd">    `beta` is a hard-set vectors with the first half of its entries</span>
<span class="sd">    equal to 10, and  the rest equal to 0.1.</span>



<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    angle : np.ndarray</span>
<span class="sd">        A 1D or 2D array representing angular components of the data.</span>
<span class="sd">        Each element corresponds to an angle in the covariate space. If</span>
<span class="sd">        `angle` is a 2D array, each row represents a different observation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        The result of the dot product between the `angle` array and the</span>
<span class="sd">        vector `beta`. This output represents the tail regression values</span>
<span class="sd">        for the input angles, which can be used to generate target values</span>
<span class="sd">        in a tail regression model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">angle</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># angle is a 1D array</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">angle</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">angle</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># angle is a 2D array</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">angle</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span></div>



<div class="viewcode-block" id="bulk_reg_fun_default">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.bulk_reg_fun_default">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bulk_reg_fun_default</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Default bulk regression function for generating target values.</span>

<span class="sd">    This function is used internally as an argument for</span>
<span class="sd">    :func:`gen_target_CovariateRV`.  The regression function in the</span>
<span class="sd">    bulk is defined in a linear model, y = &lt; beta, angle &gt;. `angle` is</span>
<span class="sd">    meant to be the angular component of the original input, and</span>
<span class="sd">    `beta` is a hard-set vectors with the first half of its entries</span>
<span class="sd">    equal to 0.1, and  the rest equal to 10.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    angle : np.ndarray</span>
<span class="sd">        A 1D or 2D array representing angular components of the data.</span>
<span class="sd">        Each element corresponds to an angle in the covariate space. If</span>
<span class="sd">        `angle` is a 2D array, each row represents a different</span>
<span class="sd">        observation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        The result of the dot product between the `angle` array and the</span>
<span class="sd">        vector `beta`. This output represents the bulk regression values</span>
<span class="sd">        for the input angles, which can be used to generate target values</span>
<span class="sd">        in a regression model.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">angle</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># angle is a 1D array</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">angle</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">angle</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># angle is a 2D array</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">angle</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span></div>



<div class="viewcode-block" id="bulk_decay_fun_default">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.bulk_decay_fun_default">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bulk_decay_fun_default</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">rv_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Default bulk decay function for generating continuous target values</span>
<span class="sd">    in a regression model. </span>

<span class="sd">    This function applies a decay transformation to the input radii,</span>
<span class="sd">    and returns : `1 / (radius) ** (rv_index)`</span>

<span class="sd">    The ouput is used in function :func:`gen_target_CovariateRV` as a\</span>
<span class="sd">     weight to be attributed to the bulk regression function, and the\</span>
<span class="sd">     final regression function in :func:`gen_target_CovariateRV` is a\</span>
<span class="sd">     weighted average between a bulk and a tail component.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radius : np.ndarray</span>
<span class="sd">        A 1D array representing the radial distances. Each element</span>
<span class="sd">        corresponds to the radius of a data point in the covariate space.</span>

<span class="sd">    rv_index : float</span>
<span class="sd">        A positive float that determines the rate of decay. Higher values</span>
<span class="sd">        result in faster decay. This parameter allows for adjustment of</span>
<span class="sd">        the decay function&#39;s sensitivity to changes in radius.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        An array containing the result of applying the decay function to</span>
<span class="sd">        each element in the `radius` array. The output represents the</span>
<span class="sd">        decayed values, which can be used to weight the contributions of</span>
<span class="sd">        different data points in a regression model.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">rv_index</span><span class="p">)</span></div>



<div class="viewcode-block" id="gen_target_CovariateRV">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.gen_target_CovariateRV">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_target_CovariateRV</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">tail_reg_fun</span><span class="o">=</span><span class="n">tail_reg_fun_default</span><span class="p">,</span>
    <span class="n">bulk_reg_fun</span><span class="o">=</span><span class="n">bulk_reg_fun_default</span><span class="p">,</span>
    <span class="n">bulk_decay_fun</span><span class="o">=</span><span class="n">bulk_decay_fun_default</span><span class="p">,</span>
    <span class="n">param_decay_fun</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate target values for covariate random variables.</span>

<span class="sd">    This function generates target values for a given set of covariate data</span>
<span class="sd">    by combining tail and bulk regression functions with a decay function.</span>
<span class="sd">    The resulting target values are influenced by both the tail and bulk</span>
<span class="sd">    regression functions, weighted by the decay function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : np.ndarray</span>
<span class="sd">        A 2D array representing covariate data. Each row corresponds to a</span>
<span class="sd">        different observation, and each column corresponds to a different</span>
<span class="sd">        covariate.</span>

<span class="sd">    tail_reg_fun : function, optional</span>
<span class="sd">        A function that computes the tail regression values based on the</span>
<span class="sd">        angular components of the covariate data. Default is</span>
<span class="sd">        `tail_reg_fun_default`.</span>

<span class="sd">    bulk_reg_fun : function, optional</span>
<span class="sd">        A function that computes the bulk regression values based on the</span>
<span class="sd">        angular components of the covariate data. Default is</span>
<span class="sd">        `bulk_reg_fun_default`.</span>

<span class="sd">    bulk_decay_fun : function, optional.</span>
<span class="sd">        A function that computes the</span>
<span class="sd">        weight of the bulk component of the regression function,</span>
<span class="sd">        based on the radial components of the covariate data. Default</span>
<span class="sd">        is `bulk_decay_fun_default`.</span>

<span class="sd">    param_decay_fun : any, optional.</span>
<span class="sd">        An additional parameter to be</span>
<span class="sd">        passed to `bulk_decay_fun`. If `bulk_decay_fun_default` is</span>
<span class="sd">        used, then `param_decay_fun` is the regular variation index of</span>
<span class="sd">        the weight, as a function of the radius. Default is 2. Larger</span>
<span class="sd">        values induce a more rapidly decaying bulk weight.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        An array of generated target values corresponding to the input</span>
<span class="sd">        covariate data. The target values are computed as a weighted</span>
<span class="sd">        combination of the tail and bulk regression values, with added</span>
<span class="sd">        Gaussian noise.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ang</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">rad</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="n">tail_mean</span> <span class="o">=</span> <span class="n">tail_reg_fun</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">bulk_mean</span> <span class="o">=</span> <span class="n">bulk_reg_fun</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">bulk_weight</span> <span class="o">=</span> <span class="n">bulk_decay_fun</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">param_decay_fun</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">ystar</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">bulk_weight</span><span class="p">)</span> <span class="o">*</span> <span class="n">tail_mean</span> <span class="o">+</span> <span class="n">bulk_weight</span> <span class="o">*</span> <span class="n">bulk_mean</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">ystar</span> <span class="o">+</span> <span class="n">noise</span>
    <span class="k">return</span> <span class="n">y</span></div>



<span class="c1"># ## toy example for functional PCA</span>
<div class="viewcode-block" id="gen_rv_functional_data">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.gen_rv_functional_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_rv_functional_data</span><span class="p">(</span>
    <span class="n">num_samples</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">alphanoise</span><span class="p">,</span> <span class="n">scalenoise</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">om1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">om2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">om3</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">om4</span><span class="o">=</span><span class="mi">4</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random regularly varying functions on a grid using</span>
<span class="sd">    Pareto-distributed coefficients and noise components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    num_samples : int</span>
<span class="sd">        Number of samples to generate.</span>
<span class="sd">    grid : array-like</span>
<span class="sd">        1D array representing the grid over which the basis functions are</span>
<span class="sd">        evaluated.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Shape parameter for the &#39;signal&#39; Pareto-distributed variables.</span>
<span class="sd">    alphanoise : float</span>
<span class="sd">        Shape parameter for the noise Pareto-distributed variables.</span>
<span class="sd">    scalenoise : float, optional</span>
<span class="sd">        Scaling factor for the noise components. Default is 5.</span>
<span class="sd">    om1, om2, om3, om4 : float, optional</span>
<span class="sd">        Frequencies used in the sine and cosine basis functions.</span>
<span class="sd">        Defaults are 1, 2, 3, 4.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 2D NumPy array of shape `(num_samples, len(grid))`, where each row</span>
<span class="sd">    represents a generated functional data sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">pareto</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
        <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">pareto</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
        <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">a3</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">scalenoise</span>
        <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">pareto</span><span class="p">(</span><span class="n">alphanoise</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">a4</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">scalenoise</span>
        <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">pareto</span><span class="p">(</span><span class="n">alphanoise</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">om1</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a2</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">om2</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a3</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">om3</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a4</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">om4</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="gen_rv_functional_data_gaussianNoise">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.gen_rv_functional_data_gaussianNoise">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_rv_functional_data_gaussianNoise</span><span class="p">(</span>
    <span class="n">num_samples</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">scalenoise</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">om1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">om2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">om3</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">om4</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">om5</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">om6</span><span class="o">=</span><span class="mi">6</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random regularly varying functions on a grid using</span>
<span class="sd">    Pareto-distributed coefficients and Gaussian noise components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    num_samples : int</span>
<span class="sd">        Number of samples to generate.</span>
<span class="sd">    grid : array-like</span>
<span class="sd">        1D array representing the grid over which the basis functions are</span>
<span class="sd">        evaluated.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Shape parameter for the Pareto-distributed variables.</span>
<span class="sd">    sd : float</span>
<span class="sd">        Standard deviation for the Gaussian noise components.</span>
<span class="sd">    scalenoise : float, optional</span>
<span class="sd">        Scaling factor for the noise components. Default is 5.</span>
<span class="sd">    om1, om2, om3, om4, om5, om6 : float, optional</span>
<span class="sd">        Frequencies used in the sine and cosine basis functions.</span>
<span class="sd">        Defaults are 1, 2, 3, 4, 5, 6.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 2D NumPy array of shape `(num_samples, len(grid))`, where each row</span>
<span class="sd">        represents a generated data sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">pareto</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">pareto</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">a3</span> <span class="o">=</span> <span class="n">scalenoise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="n">a4</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">scalenoise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="n">a5</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">scalenoise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="n">a6</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">scalenoise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">om1</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a2</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">om2</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a3</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">om3</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a4</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">om4</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a5</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">om5</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a6</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">om6</span> <span class="o">*</span> <span class="n">grid</span><span class="p">))[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>



<span class="c1"># ######</span>
<span class="c1"># subface generation for feature clustering</span>
<span class="c1"># #####</span>
<span class="c1"># #################</span>
<span class="c1"># Generate subfaces #</span>
<span class="c1"># #################</span>


<div class="viewcode-block" id="gen_subfaces">
<a class="viewcode-back" href="../../utils.html#utils.dataset_generation.gen_subfaces">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gen_subfaces</span><span class="p">(</span>
    <span class="n">dimension</span><span class="p">,</span>
    <span class="n">num_subfaces</span><span class="p">,</span>
    <span class="n">max_size</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">p_geometric</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
    <span class="n">prevent_inclusions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># include_singletons=True,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a list of random subsets (subfaces) of the set {1, ..., dimension}.</span>

<span class="sd">    This function is used for data generation in feature clustering algorithms.</span>
<span class="sd">    It creates random subsets of a specified dimension, ensuring that each subset</span>
<span class="sd">    meets certain size and inclusion criteria.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    dimension : int</span>
<span class="sd">        Dimensionality of the ambient space, i.e., the range of indices for the subsets.</span>
<span class="sd">    num_subfaces : int</span>
<span class="sd">        Number of subfaces of size &gt;= 2 to generate.</span>
<span class="sd">    max_size : int, optional</span>
<span class="sd">        Maximum size of a subface. Default is 8.</span>
<span class="sd">    p_geometric : float, optional</span>
<span class="sd">        Parameter for the geometric distribution ruling the size of subfaces.</span>
<span class="sd">        Default is 0.25.</span>
<span class="sd">    prevent_inclusions : bool, optional</span>
<span class="sd">        If True, ensures that no subface is a subset or superset of another.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    seed : int, optional</span>
<span class="sd">        Seed for random number generation to ensure reproducibility.</span>
<span class="sd">        Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    list</span>
<span class="sd">        List of generated subfaces, where each subface is represented as a list of integers.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function uses a geometric distribution to determine the size of each subface.</span>
<span class="sd">    It ensures that each feature (index) is included in at least one subface to allow</span>
<span class="sd">    for standardized components in the associated random vector (dataset).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="c1"># create a matrix of subfaces</span>
    <span class="n">subfaces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_subfaces</span><span class="p">,</span> <span class="n">dimension</span><span class="p">))</span>
    <span class="c1"># subface_size = min(np.random.geometric(p_geometric) + 1, max_size)</span>
    <span class="c1"># subfaces[0, random.sample(range(dimension), subface_size)] = 1</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">loop_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">num_subfaces</span> <span class="ow">and</span> <span class="n">loop_count</span> <span class="o">&lt;</span> <span class="mf">1e4</span><span class="p">:</span>
        <span class="n">subface_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">geometric</span><span class="p">(</span><span class="n">p_geometric</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_size</span><span class="p">)</span>
        <span class="n">subface</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
        <span class="n">subface_indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">),</span> <span class="n">subface_size</span><span class="p">)</span>
        <span class="n">subface</span><span class="p">[</span><span class="n">subface_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">valid_cond</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">prevent_inclusions</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="c1"># subface is not a subset of one of subfaces</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">subfaces</span><span class="p">[:</span><span class="n">count</span><span class="p">]</span> <span class="o">*</span> <span class="n">subface</span> <span class="o">==</span> <span class="n">subface</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span>
                    <span class="c1"># subface is not a superset either</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">subfaces</span><span class="p">[:</span><span class="n">count</span><span class="p">]</span> <span class="o">*</span> <span class="n">subface</span> <span class="o">==</span> <span class="n">subfaces</span><span class="p">[:</span><span class="n">count</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="o">==</span> <span class="mi">0</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid_cond</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">valid_cond</span><span class="p">:</span>
            <span class="n">subfaces</span><span class="p">[</span><span class="n">count</span><span class="p">,</span> <span class="n">subface_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">loop_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">idkeep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">subfaces</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">subfaces</span> <span class="o">=</span> <span class="n">subfaces</span><span class="p">[</span><span class="n">idkeep</span><span class="p">]</span>
    <span class="c1"># convert the subfaces matrix to a list</span>
    <span class="n">subfaces_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">subfaces</span><span class="p">]</span>
    <span class="c1"># features = list({int(j) for subface in subfaces_list for j in subface})</span>

    <span class="c1"># Each feature must be in at least one subface because otherwise</span>
    <span class="c1"># the associated random vector (dataset) cannot have standardized</span>
    <span class="c1"># components (columns). The last step is to add potentially</span>
    <span class="c1"># missing features:</span>

    <span class="n">missing_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">))</span> <span class="o">-</span> <span class="p">{</span><span class="n">j</span> <span class="k">for</span> <span class="n">subface</span> <span class="ow">in</span> <span class="n">subfaces_list</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">subface</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="c1"># singletons = []</span>

    <span class="k">if</span> <span class="n">missing_features</span><span class="p">:</span>
        <span class="c1">#       if include_singletons:</span>
        <span class="c1"># singletons = [[int(j)] for j in missing_features]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">missing_features</span><span class="p">:</span>
            <span class="n">subfaces_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)])</span>
        <span class="c1"># else:</span>
        <span class="c1">#     if len(missing_features) &gt; 1:</span>
        <span class="c1">#         subfaces_list.append(missing_features)</span>
        <span class="c1">#     if len(missing_features) == 1:</span>
        <span class="c1">#         missing_features.append(list(set(range(dimension)) -</span>
        <span class="c1">#                                      set(missing_features))[0])</span>
        <span class="c1">#         subfaces_list.append(missing_features)</span>

    <span class="n">converted_subfaces</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">subfaces_list</span><span class="p">]</span>

    <span class="c1"># if include_singletons:</span>
    <span class="c1">#     return converted_subfaces, features, singletons</span>
    <span class="k">return</span> <span class="n">converted_subfaces</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">MLExtreme</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../supervised.html">supervised subpackage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unsupervised.html">unsupervised subpackage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">utils subpackage</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Anne Sabourin, Pierre-Antoine Amiand-Leroy.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>